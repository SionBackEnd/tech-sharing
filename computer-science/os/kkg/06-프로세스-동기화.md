# 06. 프로세스 동기화

## Race Condition

> 여러 프로세스들이 동시에 공유 데이터에 접근하는 상황

### OS에서 Race Condition은 언제 발생 하는가

1. 커널 수행 중 Interrupt 발생 시
2. Process가 System Call을 하여 kernel Mode로 수행 중인데 Context Switch가 일어나는 경우

   - 해결: 커널 모드에서 수행 중일 때는 CPU를 Preempt하지 않게 구현

3. Multiprocessor에서 Shared Memory 내의 Kernel Data

   - 해결 방법 1: 한 번에 하나의 CPU만 커널에 들어갈 수 있게 한다.
   - 해결 방법 2: 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 Lock / Unlock을 한다.

## Process Synchronization 문제

- 공유 데이터(Shared Data)의 동시 접근(Concurrent Access)은 데이터의 불일치 문제(Inconsistency)를 발생시킬 수 있다.
- 일관성(Consistency) 유지를 위해서는 협력 프로세스(Cooperating Process) 간의 실행 순서(Orderly Execution)를 정해주는 메커니즘 필요

### 프로그램적 해결법의 충족 조건

- Mutual Exclusion (상호 배제)
- Progress

  - 아무도 Critical Section에 있지 않은 상태에서 Critical Section에 들어가고자 하는 프로세서가 있으면 들어가게 해주어야 한다.

- Bounded Waiting (유한 대기)

### Peterson's Algorithm

```c
do {
    flag[i] = true;
    turn = j;
    while (flag[j] && turn == j);
    // Critical Section
    flag[i] = false;
    // Remainder Section
} while (1);
```

- 3가지 조건 만족
- Busy Wating(= Spin Lock)

### Synchronization Hardware

- 하드웨어적으로 Test & Modify를 Atomic하게 수행할 수 있도록 지원

```c
//Synchronization Variable
boolean lock = false;

// Process P_i
do {
    while (Test_and_Set(lock));
    // Critical Section
    lock = false;
    // Remainder Section
}
```
